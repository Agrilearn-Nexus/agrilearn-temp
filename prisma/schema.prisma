generator client {
  provider = "prisma-client"
  output   = "../src/.generated/"
}

datasource db {
  provider = "postgresql"
}

enum ReferenceType {
  SOCAIL_MEDIA
  WHATSAPP_GROUP
  PERSON
  WEBSITE
  MAIL
}

enum SubmissionStatus {
  PROCESSING
  VALIDATING
  SAVED
  FAILED
  COMPLETED
  PAYMENT_VERIFIED
}

enum ContactRole {
  STUDENT
  FARMER
  PROFESSOR
  ORGANIZATION
  OTHER
}

model User {
  id            String    @id @default(uuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?
  accounts      Account[]
  sessions      Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Submissions {
  id           String @id @unique @default(uuid(7))
  submissionId String @unique

  status        SubmissionStatus @default(PROCESSING)
  failureReason String?
  // personal Details

  submissionDetail    String  @default("N/A")
  name                String
  email               String  @unique
  phone               String  @unique
  whatsappNumber      String  @unique
  whatsappGroupJoined Boolean @default(false)
  education           String
  currentDesignation  String
  institute           String
  organization        String
  address             String
  city                String
  district            String
  postalCode          String
  state               String

  // reference
  submissionReference   SubmissionReference @relation(fields: [submissionReferenceId], references: [id])
  submissionReferenceId String

  // payments record
  payment Payment?

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  errorLogs ErrorLog[]

  @@index([submissionReferenceId])
}

model SubmissionReference {
  id String @id @unique @default(uuid(7))

  type              ReferenceType
  personName        String?
  personDesignation String?
  Submissions       Submissions[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, personName])
  @@index([type])
}

model Payment {
  id String @id @unique @default(uuid(7))

  upiId       String
  paymentDate DateTime
  upiImageId  String?
  UpiImageUrl String?
  amountPaid  Float    @default(0.0)

  submissionId String      @unique
  submission   Submissions @relation(fields: [submissionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EventCounter {
  year  Int @id
  value Int @default(0)
}

model ErrorLog {
  id       String  @id @default(uuid())
  source   String
  message  String
  stack    String? @db.Text
  metadata Json?

  submissionId String?
  submission   Submissions? @relation(fields: [submissionId], references: [id], onDelete: SetNull)

  resolved  Boolean  @default(false)
  createdAt DateTime @default(now())
}

model ContactSubmission {
  id      String      @id @default(uuid())
  name    String
  email   String
  phone   String
  role    ContactRole
  subject String
  message String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([createdAt])
}
